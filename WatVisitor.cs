/*
  Drac compiler - WebAssembly text file (Wat) code generator.
  Copyright (C) 2020-2021 Ariel Ortiz, ITESM CEM

  Copyright (C) 2021
  Luis Enrique Neri Pérez - A01745995
  Luis Miguel Baqueiro Vallejo - A01745997
  Francisco Javier Zavala Torres - A01746851

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
falta:
  -revisar strings to int??
  -revisar arrays??
*/

using System;
using System.Text;
using System.Collections.Generic;

namespace Drac {

    class WatVisitor {

        IDictionary<string, HashSet<string>> LocalSymbolTable;

        string function_name = "";
        int nested = 0;
        int cantTabs = 0;
        string block;
        string passblock;

        int ret = 0;

        public string tabs(){
          string regresar = "\t";
          for(int i = 0; i < cantTabs; i++){
            regresar += "\t";
          }
          return regresar;
        }

        public string tabs(int sumar){
          string regresar = "\t";
          if(sumar == -99 || sumar == -98){
            regresar = "";
          }
          for(int i = 0; i < cantTabs; i++){
            regresar += "\t";
          }
          if( sumar == -98){
            cantTabs -= 1;
          }else if(sumar != -99){
            cantTabs += sumar;
          }
          return regresar;
        }

        public WatVisitor(IDictionary<string, HashSet<string>> LocalSymbolTable) {
            this.LocalSymbolTable = LocalSymbolTable;
        }


        public string Visit(ProgramN node) {
            return ";; WebAssembly text format code generated by "
                + "the drac compiler.\n\n"
                + "(module\n"
                + " (import \"drac\" \"printi\" (func $printi (param i32)))\n"
                + " (import \"drac\" \"printc\" (func $printc (param i32)))\n"
                + " (import \"drac\" \"prints\" (func $prints (param i32)))\n"
                + " (import \"drac\" \"println\" (func $println))\n"
                + " (import \"drac\" \"readi\" (func $readi (result i32)))\n"
                + " (import \"drac\" \"reads\" (func $reads (result i32)))\n"
                + " (import \"drac\" \"new\" (func $new (param i32) (result i32)))\n"
                + " (import \"drac\" \"size\" (func $size (param i32) (result i32)))\n"
                + " (import \"drac\" \"add\" (func $add (param i32) (param i32) (result i32)))\n"
                + " (import \"drac\" \"get\" (func $get (param i32) (param i32) (result i32)))\n"
                + " (import \"drac\" \"set\" (func $set (param i32) (param i32) (param i32)))\n"
                + globalDefs((dynamic) node[0]) // VarList
                + Visit((dynamic) node[1]) // FunList
                + ")\n";
        }

        // Lists
        public string globalDefs(VarList nodeD){
          string regresa = "";
          foreach(var node in nodeD){
            regresa += tabs() + $"(global ${node.AnchorToken.Lexeme} (mut i32) (i32.const 0))\n";
          }
          return regresa;
        }
        public string Visit(VarList node) {
            return VisitChildren((dynamic) node);
        }

        public string Visit(VarDef node) {
          return tabs() + $"{getVariableCategory(node)}.set ${node.AnchorToken.Lexeme}\n";
        }

        // Function Definition and Export
        public string Visit(FunList node) {
            return VisitChildren((dynamic) node);
        }

        // Module Local Function Definition
        public string Visit(FunDef node) {
          function_name = node.AnchorToken.Lexeme;
          ret = 1;
          string regresar = "";
          if(function_name == "main"){
            regresar = "\n" + tabs(1) + $"(func\n"
            + tabs() + "(export \"main\")\n"
            + Params((dynamic) node[0]);
          }
          else{
            regresar = "\n" + tabs(1) + $"(func ${node.AnchorToken.Lexeme}\n"
            + Params((dynamic) node[0]);
          }
          string red = tabs() + "(result i32)\n";
          string regresar2 = tabs() + "(local $_temp i32)\n"
          + VisitChildren((dynamic) node,1);

          if(ret == 0){
            return regresar + red + regresar2 + tabs() + "i32.const 0\n"
			      + tabs(-1) + "return\n" + tabs() + ")\n";
          }
          return regresar + red + regresar2  + tabs() + "i32.const 0\n"
          + tabs(-1) + "return\n" + tabs() + ")\n";
        }

        public string Params(ExprList node){
          string regresa = "\n";
          foreach(var nodeC in node){
            regresa += tabs() + $"(param ${nodeC.AnchorToken.Lexeme} i32)\n";
          }
          return regresa;
        }

        public string Visit(StatementList node) {
            return VisitChildren((dynamic) node);
        }

        public string Visit(FunCall node) {
          if(node.childs() > 0){
            return Visit((dynamic) node[0])
            + tabs() +$"call ${node.AnchorToken.Lexeme}\n";
          }
          else{
            return tabs() + $"call ${node.AnchorToken.Lexeme}\n";
          }

        }

        public string Visit(Assignment node) {
          if(node[0].childs() > 1 && node[0].GetType() == new ExprList().GetType()){
            string arr = "";
            foreach(var n in node[0]){
              arr += tabs() + "local.get $_temp\n"
              + Visit((dynamic) n)
              + tabs() + "call $add\n"
              + tabs() + "drop\n";
            }
            return tabs() + "i32.const 0\n"
            + tabs() + "call $new\n"
            + tabs() + "local.set $_temp\n"
            + tabs() + "local.get $_temp\n"
            + arr
            + tabs() + $"{getVariableCategory(node)}.set ${node.AnchorToken.Lexeme}\n";
          }
            return Visit((dynamic) node[0])
                + tabs() + $"{getVariableCategory(node)}.set ${node.AnchorToken.Lexeme}\n";
        }

        public string Visit(Var node) {
            return tabs() + $"{getVariableCategory(node)}.get ${node.AnchorToken.Lexeme}\n";
        }

        public string Visit(ExprList node) {
          return VisitChildren((dynamic) node);
        }

        public string Visit(DeclarationList node) {
          string regresar = "";
          foreach(var nodeC in node){
            regresar += tabs() + $"(local ${nodeC.AnchorToken.Lexeme} i32)\n";
          }
          return regresar;
        }

        public string Visit(Inc node) {
            return Visit((dynamic) node[0])
                + tabs() +"i32.const 1\n"
                + tabs() +"i32.add\n"
                + tabs() +$"{getVariableCategory(node[0])}.set ${node[0].AnchorToken.Lexeme}\n";
        }
        public string Visit(Dec node) {
            return Visit((dynamic) node[0])
                + tabs() +"i32.const 1\n"
                + tabs() + "i32.sub\n"
                + tabs() +  $"{getVariableCategory(node[0])}.set ${node[0].AnchorToken.Lexeme}\n";
        }

        public string Visit(If node) {
            return Visit((dynamic) node[0])
                + tabs(1) + "if\n"
                + VisitChildren((dynamic) node,1)
                + tabs(-98) + "end\n";
        }

        public string Visit(Elseif node) {
            return  tabs(-99) + "else\n"
                + Visit((dynamic) node[0])
                + tabs(1) + "if\n"
                + VisitChildren((dynamic) node,1)
                + tabs(-98) + "end\n";
        }

        public string Visit(Else node) {
            return  tabs(-99) + "else\n"
              + Visit((dynamic) node[0]);
        }

        public string Visit(While node){
           passblock = block;
            nested += 1;
            block = formatNested();
            nested += 1;
            var loop = formatNested();
            string ret = tabs(1) + $"block ${block}\n"
                + tabs(1) + $"loop ${loop}\n\n"
                + Visit((dynamic) node[0]) + "\n"
                + tabs() + "i32.eqz\n"
                + tabs() + $"br_if ${block}\n\n"
                + Visit((dynamic) node[1]) + "\n"
                + tabs(-1) +$"br ${loop}\n"
                + tabs(-1) +"end\n"
                + tabs() +"end\n";
            block = passblock;
            return ret;
        }

        public string Visit(Do node){
           passblock = block;
            nested += 1;
            block = formatNested();
            nested += 1;
            var loop = formatNested();
            string ret = tabs(1) + $"block ${block}\n"
                + tabs(1) + $"loop ${loop}\n"
                + Visit((dynamic) node[0]) + "\n"
                + Visit((dynamic) node[1][0]) + "\n"
                + tabs() + "i32.eqz\n"
                + tabs() + $"br_if ${block}\n\n"
                + tabs(-1) + $"br ${loop}\n"
                + tabs(-1) + "end\n"
                + tabs() + "end\n";
            block = passblock;
            return ret;
        }

        public string Visit(Break node){
          return tabs() + $"br ${block}\n";
        }

        public string Visit(Return node){
          ret = 0;
          if(node[0].childs() > 1 && node[0].GetType() == new ExprList().GetType()){
            string arr = "";
            foreach(var n in node[0]){
              arr += tabs() + "local.get $_temp\n"
              + Visit((dynamic) n)
              + tabs() + "call $add\n"
              + tabs() + "drop\n";
            }
            return tabs() + "i32.const 0\n"
            + tabs() + "call $new\n"
            + tabs() + "local.set $_temp\n"
            + tabs() + "local.get $_temp\n"
            + arr
            + tabs() + "return\n";
          }
          return Visit((dynamic) node[0])
          + tabs() + "return\n";
        }

        public string Visit(Or node){
            return Visit((dynamic) node[0])
            + tabs(1) + "if(result i32)\n"
            + tabs(-1) + "i32.const 1\n"
            + tabs(1) + "else\n"
            + Visit((dynamic) node[1])
            + tabs() + "i32.eqz\n"
            + tabs(-1) + "i32.eqz\n"
            + tabs() + "end\n";
        }

        public string Visit(And node){
            return Visit((dynamic) node[0])
            + tabs(1) + "if(result i32)\n"
            + Visit((dynamic) node[1])
            + tabs() + "i32.eqz\n"
            + tabs(-1) + "i32.eqz\n"
            + tabs(1) + "else\n"
            + tabs(-1) + "i32.const 0\n"
            + tabs() + "end\n";
        }

        public string Visit(Comp node){
            return Visit((dynamic) node[0])
            + Visit((dynamic) node[1])
            + tabs() + "i32.eq\n";
        }

        public string Visit(Dif node){
            return Visit((dynamic) node[0])
            + Visit((dynamic) node[1])
            + tabs() + "i32.eq\n"
            + tabs() + "i32.eqz\n";
        }

        public string Visit(LessT node){
            return Visit((dynamic) node[0])
            + Visit((dynamic) node[1])
            + tabs() + "i32.lt_s\n";
        }

        public string Visit(LessE node){
            return Visit((dynamic) node[0])
            + Visit((dynamic) node[1])
            + tabs() + "i32.le_s\n";
        }

        public string Visit(MoreT node){
            return Visit((dynamic) node[1])
            + Visit((dynamic) node[0])
            + tabs() + "i32.lt_s\n";
        }

        public string Visit(MoreE node){
            return Visit((dynamic) node[1])
            + Visit((dynamic) node[0])
            + tabs() + "i32.le_s\n";
        }

        public string Visit(Add node){
            return Visit((dynamic) node[0])
            + Visit((dynamic) node[1])
            + tabs() + "i32.add\n";
        }

        public string Visit(Minus node){
            return Visit((dynamic) node[0])
            + Visit((dynamic) node[1])
            + tabs() + "i32.sub\n";
        }

        public string Visit(Mul node){
            return Visit((dynamic) node[1])
            + Visit((dynamic) node[0])
            + tabs() + "i32.mul\n";
        }

        public string Visit(Div node){
            return Visit((dynamic) node[0])
            + Visit((dynamic) node[1])
            + tabs() + "i32.div_s\n";
        }

        public string Visit(Mod node){
            return Visit((dynamic) node[0])
            + Visit((dynamic) node[1])
            + tabs() + "i32.rem_s\n";
        }

        public string Visit(UPlus node){
            return Visit((dynamic) node[0]);
        }

        public string Visit(UMinus node){
            return tabs() + "i32.const 0\n"
            + Visit((dynamic) node[0])
            + tabs() + "i32.sub\n";
        }

        public string Visit(UNot node){
            return Visit((dynamic) node[0])
            + tabs() + "i32.const 0\n"
            + tabs() + "i32.eq\n";
        }

        public string Visit(True node){
            return tabs() + "i32.const 1\n";
        }

        public string Visit(False node){
            return tabs() + "i32.const 0\n";
        }

        public string Visit(IntLit node){
            return tabs() + $"i32.const {node.AnchorToken.Lexeme}\n";
        }

        public string Visit(CharLit node){
          char[] str = node.AnchorToken.Lexeme.ToCharArray();
          int i = 1;
          int c = 0;
          if(str[i] == '\\'){
            i++;
            if(str[i] == 'n'){
              c = 10;
            }
            else if(str[i] == '"'){
              c = 34;
            }
            else if(str[i] == 'r'){
              c = 13;
            }
            else if(str[i] == 't'){
              c = 9;
            }
            else if(str[i] == '\\'){
              c = 92;
            }
            else if(str[i] == '\''){
              c = 39;
            }
            else if(str[i] == 'u'){
              string w = "";
              w += str[i+1];
              w += str[i+2];
              w += str[i+3];
              w += str[i+4];
              w += str[i+5];
              w += str[i+6];
              c = int.Parse(w, System.Globalization.NumberStyles.HexNumber);
              i += 6;
            }
          }else{
            c = Convert.ToInt32(str[1]);
          }
          return tabs() + $"i32.const {c}\n";
        }

        public string Visit(StringLit node){
          string regresar = tabs() + "i32.const 0\n"
          + tabs() + "call $new\n"
          + tabs() + "local.set $_temp\n"
          + tabs() + "local.get $_temp\n";
          char[] str = node.AnchorToken.Lexeme.ToCharArray();
          for(int i = 1; i < str.Length - 1; i++){
            regresar += tabs() + "local.get $_temp\n";
            if(str[i] == '\\'){
              i++;
              int c = 0;
              if(str[i] == 'n'){
                c = 10;
              }
              else if(str[i] == '"'){
                c = 34;
              }
              else if(str[i] == 'r'){
                c = 13;
              }
              else if(str[i] == 't'){
                c = 9;
              }
              else if(str[i] == '\\'){
                c = 92;
              }
              else if(str[i] == '\''){
                c = 39;
              }
              else if(str[i] == 'u'){
                string w = "";
                w += str[i+1];
                w += str[i+2];
                w += str[i+3];
                w += str[i+4];
                w += str[i+5];
                w += str[i+6];
                c = int.Parse(w, System.Globalization.NumberStyles.HexNumber);
                i += 6;
              }
              regresar += tabs() + "i32.const " + c + "\n";
            }else{
              regresar += tabs() + "i32.const " + Convert.ToInt32(str[i]) + "\n";
            }
            regresar += tabs() + "call $add\n";
            regresar += tabs() + "drop\n";
          }
          return regresar;
        }

        string VisitChildren(Node node) {
            var sb = new StringBuilder();
            foreach (var n in node) {
                sb.Append(Visit((dynamic) n));
            }
            return sb.ToString();
        }

        string VisitChildren(Node node, int cambio) {
          int i = 0;
          var sb = new StringBuilder();
          foreach (var n in node) {
            if(i >= cambio){
              sb.Append(Visit((dynamic) n));
            }
            i++;
          }
          return sb.ToString();
        }

        public string getVariableCategory(Node node){
          foreach(var n in LocalSymbolTable[function_name]){
              if(n == node.AnchorToken.Lexeme){
                return "local";
              }
          }
          return "global";
        }

        public string formatNested(){
            if (nested < 10){
                return "0000" +nested.ToString();
            }else if(nested <100){
                return "000" +nested.ToString();
            }else if(nested <1000){
                return "00" +nested.ToString();
            }else if(nested <10000){
                return "0" +nested.ToString();
            }else{
                return nested.ToString();
            }
        }
    }
}
